package shamir

import (
	"crypto/rand"
	"fmt"
)

// ShareOverhead represents the byte overhead added to each share.
// Each share contains one additional byte for the x-coordinate identifier.
const ShareOverhead = 1

// Split divides a secret into n shares using Shamir's Secret Sharing algorithm.
// The secret can be reconstructed from any k shares where k >= threshold.
//
// Parameters:
//   - secret: The data to be split (must not be empty)
//   - parts: Total number of shares to generate (2-255)
//   - threshold: Minimum shares needed for reconstruction (2 <= threshold <= parts)
//
// Returns:
//   - [][]byte: Array of shares, each containing the x-coordinate and y-values
//   - error: Validation error if parameters are invalid
//
// Each share is len(secret)+1 bytes: [x-coordinate][y-values...]
// The x-coordinate uniquely identifies each share (1-based indexing).
func Split(secret []byte, parts, threshold int) ([][]byte, error) {
	// Validate all input parameters
	if err := validateSplitParams(secret, parts, threshold); err != nil {
		return nil, err
	}

	secretLen := len(secret)
	shares := make([][]byte, parts)
	
	// Create polynomial coefficients: secret is constant term (degree 0)
	// Generate (threshold-1) random coefficients for higher degree terms
	coeffs := make([][]byte, threshold)
	coeffs[0] = make([]byte, secretLen)
	copy(coeffs[0], secret) // Constant term = secret
	
	// Generate random coefficients for polynomial terms of degree 1 to threshold-1
	for i := 1; i < threshold; i++ {
		coeffs[i] = make([]byte, secretLen)
		if _, err := rand.Read(coeffs[i]); err != nil {
			// Clean up any allocated coefficients on error
			for j := 0; j < i; j++ {
				secureZeroBytes(coeffs[j])
			}
			return nil, fmt.Errorf("shamir: failed to generate random coefficients: %w", err)
		}
	}

	// Evaluate polynomial at each point x=1,2,...,parts to generate shares
	// Each share: [x-coordinate][polynomial(x) for each secret byte]
	for i := 0; i < parts; i++ {
		x := byte(i + 1) // x-coordinates are 1-based (never 0)
		shares[i] = make([]byte, secretLen+ShareOverhead)
		shares[i][0] = x // Store x-coordinate as first byte
		
		// Evaluate polynomial at point x for all secret bytes simultaneously
		gfPolyEvalSlice(shares[i][1:], coeffs, x)
	}

	// Securely clear polynomial coefficients from memory
	for i := range coeffs {
		if coeffs[i] != nil {
			secureZeroBytes(coeffs[i])
		}
	}

	return shares, nil
}

// Combine reconstructs the original secret from a set of shares using Lagrange interpolation.
// Requires at least threshold number of shares that were generated by Split.
//
// Parameters:
//   - parts: Array of shares (at least 2 shares required)
//
// Returns:
//   - []byte: The reconstructed secret
//   - error: Validation error if shares are invalid or insufficient
//
// The reconstruction uses Lagrange interpolation to evaluate the polynomial at x=0,
// which gives the original secret (the constant term of the polynomial).
func Combine(parts [][]byte) ([]byte, error) {
	// Validate share format and consistency
	if err := validateCombineParams(parts); err != nil {
		return nil, err
	}

	secretLen := len(parts[0]) - ShareOverhead

	// Extract x-coordinates (share identifiers) for Lagrange interpolation
	xCoords := make([]byte, len(parts))
	for i, part := range parts {
		xCoords[i] = part[0]
	}

	// Reconstruct secret by interpolating polynomial at x=0 for each byte position
	secret := make([]byte, secretLen)
	
	for byteIdx := 0; byteIdx < secretLen; byteIdx++ {
		// Extract y-coordinates for this byte position across all shares
		yCoords := make([]byte, len(parts))
		for i, part := range parts {
			yCoords[i] = part[byteIdx+1]
		}
		
		// Use Lagrange interpolation to find polynomial value at x=0
		secret[byteIdx] = lagrangeInterpolate(xCoords, yCoords, 0)
		
		// Clear temporary y-coordinates from memory
		secureZeroBytes(yCoords)
	}

	// Clear x-coordinates from memory
	secureZeroBytes(xCoords)

	return secret, nil
}

// lagrangeInterpolate performs Lagrange interpolation to evaluate a polynomial at point x.
// Given points (xCoords[i], yCoords[i]), reconstructs the polynomial value at x.
// This is the core mathematical operation for secret reconstruction.
func lagrangeInterpolate(xCoords, yCoords []byte, x byte) byte {
	var result byte
	n := len(xCoords)

	// For each point (xCoords[i], yCoords[i]), calculate its Lagrange basis polynomial
	for i := 0; i < n; i++ {
		numerator := byte(1)
		denominator := byte(1)

		// Calculate the Lagrange basis polynomial L_i(x)
		// L_i(x) = ∏(j≠i) (x - xCoords[j]) / (xCoords[i] - xCoords[j])
		for j := 0; j < n; j++ {
			if i == j {
				continue // Skip when j == i
			}
			
			// In GF(256): subtraction is the same as addition (XOR)
			numerator = gfMult(numerator, gfAdd(x, xCoords[j]))
			denominator = gfMult(denominator, gfAdd(xCoords[i], xCoords[j]))
		}

		// Skip this term if denominator is zero (shouldn't happen with valid shares)
		if denominator == 0 {
			continue
		}

		// Calculate the contribution of this point: yCoords[i] * L_i(x)
		basis := gfDiv(numerator, denominator)
		term := gfMult(yCoords[i], basis)
		result = gfAdd(result, term)
	}

	return result
}

// lagrangeInterpolateSlice performs vectorized Lagrange interpolation for multiple polynomials.
// This is an optimized version that processes multiple byte positions simultaneously.
// Currently unused but kept for potential future performance optimizations.
func lagrangeInterpolateSlice(dst []byte, xCoords []byte, yCoords [][]byte, x byte) {
	n := len(xCoords)
	if n == 0 || len(dst) == 0 {
		return
	}

	for i := range dst {
		dst[i] = 0
	}

	temp := make([]byte, len(dst))
	
	for i := 0; i < n; i++ {
		numerator := byte(1)
		denominator := byte(1)

		for j := 0; j < n; j++ {
			if i == j {
				continue
			}
			
			numerator = gfMult(numerator, gfAdd(x, xCoords[j]))
			denominator = gfMult(denominator, gfAdd(xCoords[i], xCoords[j]))
		}

		if denominator == 0 {
			continue
		}

		basis := gfDiv(numerator, denominator)
		gfMultSlice(temp, yCoords[i], basis)
		gfAddSlice(dst, dst, temp)
	}
}